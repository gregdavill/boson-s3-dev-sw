From 79188b6e7f2d126e2bd96376762f6af960dbb2f2 Mon Sep 17 00:00:00 2001
From: Greg Davill <greg.davill@gmail.com>
Date: Mon, 11 Jul 2022 22:55:34 +0930
Subject: [PATCH 3/3] libavcodec/cedrus264: switch from ION to CMA

update ve/h264enc based on utilities: https://github.com/uboborov/cedrus
---
 libavcodec/arm/sunxi/h264enc.c   |  69 ++----
 libavcodec/arm/sunxi/ion.h       | 377 -----------------------------
 libavcodec/arm/sunxi/ion_sunxi.h | 108 ---------
 libavcodec/arm/sunxi/ve.c        | 398 ++++++++-----------------------
 libavcodec/arm/sunxi/ve.h        |  58 +----
 libavcodec/cedrus264.c           |  31 +--
 6 files changed, 146 insertions(+), 895 deletions(-)
 delete mode 100644 libavcodec/arm/sunxi/ion.h
 delete mode 100644 libavcodec/arm/sunxi/ion_sunxi.h

diff --git a/libavcodec/arm/sunxi/h264enc.c b/libavcodec/arm/sunxi/h264enc.c
index 320966a713..2400ccb072 100644
--- a/libavcodec/arm/sunxi/h264enc.c
+++ b/libavcodec/arm/sunxi/h264enc.c
@@ -34,22 +34,20 @@ struct h264enc_internal {
 	unsigned int mb_width, mb_height, mb_stride;
 	unsigned int crop_right, crop_bottom;
 
-	struct ve_mem *luma_buffer;
-	struct ve_mem *chroma_buffer;
+	uint8_t *luma_buffer, *chroma_buffer;
 	unsigned int input_buffer_size;
 	enum color_format input_color_format;
 
-	struct ve_mem *bytestream_buffer;
+	uint8_t *bytestream_buffer;
 	unsigned int bytestream_buffer_size;
 	unsigned int bytestream_length;
 
 	struct h264enc_ref_pic {
-		struct ve_mem *luma_buffer;
-		struct ve_mem *chroma_buffer;
-		struct ve_mem *extra_buffer; /* unknown purpose, looks like smaller luma */
+		void *luma_buffer, *chroma_buffer;
+		void *extra_buffer; /* unknown purpose, looks like smaller luma */
 	} ref_picture[2];
 
-	struct ve_mem *extra_buffer_line, *extra_buffer_frame; /* unknown purpose */
+	void *extra_buffer_line, *extra_buffer_frame; /* unknown purpose */
 
 	void *regs;
 
@@ -233,8 +231,6 @@ h264enc *h264enc_new(const struct h264enc_params *p)
 {
 	h264enc *c;
 	int i;
-	void *a;
-	struct ve_mem *m;
 
 	/* check parameter validity */
 	if (!IS_ALIGNED(p->src_width, 16) || !IS_ALIGNED(p->src_height, 16) ||
@@ -299,14 +295,7 @@ h264enc *h264enc_new(const struct h264enc_params *p)
 	if (c->luma_buffer == NULL)
 		goto nomem;
 
-	a = c->luma_buffer->virt + p->src_width * p->src_height;
-	m = malloc(sizeof(struct ve_mem));
-	if (m == NULL)
-		goto nomem;
-	
-	m->virt = a;
-	m->phys = ve_virt2phys(a);
-	c->chroma_buffer = m;//c->luma_buffer->virt + p->src_width * p->src_height;
+	c->chroma_buffer = c->luma_buffer + p->src_width * p->src_height;
 
 	/* allocate bytestream output buffer */
 	c->bytestream_buffer_size = 1 * 1024 * 1024;
@@ -320,14 +309,7 @@ h264enc *h264enc_new(const struct h264enc_params *p)
 	for (i = 0; i < 2; i++)
 	{
 		c->ref_picture[i].luma_buffer = ve_malloc(luma_size + chroma_size);
-		a = c->ref_picture[i].luma_buffer->virt + luma_size;
-		m = malloc(sizeof(struct ve_mem));
-		if (m == NULL)
-			goto nomem;
-		m->virt = a;
-		m->phys = ve_virt2phys(a);
-		c->ref_picture[i].chroma_buffer = m;//c->ref_picture[i].luma_buffer->virt + luma_size;
-		
+		c->ref_picture[i].chroma_buffer = c->ref_picture[i].luma_buffer + luma_size;
 		c->ref_picture[i].extra_buffer = ve_malloc(luma_size / 4);
 		if (c->ref_picture[i].luma_buffer == NULL || c->ref_picture[i].extra_buffer == NULL)
 			goto nomem;
@@ -349,12 +331,12 @@ nomem:
 
 void *h264enc_get_input_buffer(const h264enc *c)
 {
-	return c->luma_buffer->virt;
+	return c->luma_buffer;
 }
 
 void *h264enc_get_bytestream_buffer(const h264enc *c)
 {
-	return c->bytestream_buffer->virt;
+	return c->bytestream_buffer;
 }
 
 unsigned int h264enc_get_bytestream_length(const h264enc *c)
@@ -369,13 +351,13 @@ int h264enc_encode_picture(h264enc *c)
 	c->regs = ve_get(VE_ENGINE_AVC, 0);
 
 	/* flush buffers (output because otherwise we might read old data later) */
-	ve_flush_cache(c->bytestream_buffer);
-	ve_flush_cache(c->luma_buffer);
+	ve_flush_cache(c->bytestream_buffer, c->bytestream_buffer_size);
+	ve_flush_cache(c->luma_buffer, c->input_buffer_size);
 
 	/* set output buffer */
 	writel(0x0, c->regs + VE_AVC_VLE_OFFSET);
-	writel(c->bytestream_buffer->phys, c->regs + VE_AVC_VLE_ADDR);
-	writel(c->bytestream_buffer->phys + c->bytestream_buffer_size - 1, c->regs + VE_AVC_VLE_END);
+	writel(ve_virt2phys(c->bytestream_buffer), c->regs + VE_AVC_VLE_ADDR);
+	writel(ve_virt2phys(c->bytestream_buffer) + c->bytestream_buffer_size - 1, c->regs + VE_AVC_VLE_END);
 	writel(c->bytestream_buffer_size * 8, c->regs + VE_AVC_VLE_MAX);
 
 	/* write headers */
@@ -395,28 +377,28 @@ int h264enc_encode_picture(h264enc *c)
 	writel(c->input_color_format << 29, c->regs + VE_ISP_CTRL);
 
 	/* set input buffer */
-	writel(c->luma_buffer->phys, c->regs + VE_ISP_INPUT_LUMA);
-	writel(c->chroma_buffer->phys, c->regs + VE_ISP_INPUT_CHROMA);
-	
+	writel(ve_virt2phys(c->luma_buffer), c->regs + VE_ISP_INPUT_LUMA);
+	writel(ve_virt2phys(c->chroma_buffer), c->regs + VE_ISP_INPUT_CHROMA);
+
 	/* set reconstruction buffers */
 	struct h264enc_ref_pic *ref_pic = &c->ref_picture[c->current_frame_num % 2];
-	writel(ref_pic->luma_buffer->phys, c->regs + VE_AVC_REC_LUMA);
-	writel(ref_pic->chroma_buffer->phys, c->regs + VE_AVC_REC_CHROMA);
-	writel(ref_pic->extra_buffer->phys, c->regs + VE_AVC_REC_SLUMA);
+	writel(ve_virt2phys(ref_pic->luma_buffer), c->regs + VE_AVC_REC_LUMA);
+	writel(ve_virt2phys(ref_pic->chroma_buffer), c->regs + VE_AVC_REC_CHROMA);
+	writel(ve_virt2phys(ref_pic->extra_buffer), c->regs + VE_AVC_REC_SLUMA);
 
 	/* set reference buffers */
 	if (c->current_slice_type != SLICE_I)
 	{
 		ref_pic = &c->ref_picture[(c->current_frame_num + 1) % 2];
-		writel(ref_pic->luma_buffer->phys, c->regs + VE_AVC_REF_LUMA);
-		writel(ref_pic->chroma_buffer->phys, c->regs + VE_AVC_REF_CHROMA);
-		writel(ref_pic->extra_buffer->phys, c->regs + VE_AVC_REF_SLUMA);
+		writel(ve_virt2phys(ref_pic->luma_buffer), c->regs + VE_AVC_REF_LUMA);
+		writel(ve_virt2phys(ref_pic->chroma_buffer), c->regs + VE_AVC_REF_CHROMA);
+		writel(ve_virt2phys(ref_pic->extra_buffer), c->regs + VE_AVC_REF_SLUMA);
 	}
 
 	/* set unknown purpose buffers */
-	writel(c->extra_buffer_line->phys, c->regs + VE_AVC_MB_INFO);
-	writel(c->extra_buffer_frame->phys, c->regs + VE_AVC_UNK_BUF);
-	
+	writel(ve_virt2phys(c->extra_buffer_line), c->regs + VE_AVC_MB_INFO);
+	writel(ve_virt2phys(c->extra_buffer_frame), c->regs + VE_AVC_UNK_BUF);
+
 	/* enable interrupt and clear status flags */
 	writel(readl(c->regs + VE_AVC_CTRL) | 0xf, c->regs + VE_AVC_CTRL);
 	writel(readl(c->regs + VE_AVC_STATUS) | 0x7, c->regs + VE_AVC_STATUS);
@@ -451,4 +433,3 @@ int h264enc_encode_picture(h264enc *c)
 
 	return (status & 0x3) == 0x1;
 }
-
diff --git a/libavcodec/arm/sunxi/ion.h b/libavcodec/arm/sunxi/ion.h
deleted file mode 100644
index e777c69d48..0000000000
--- a/libavcodec/arm/sunxi/ion.h
+++ /dev/null
@@ -1,377 +0,0 @@
-/*
- * include/linux/ion.h
- *
- * Copyright (C) 2011 Google, Inc.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#ifndef _LINUX_ION_H
-#define _LINUX_ION_H
-
-#include <stdlib.h>
-#include <linux/types.h>
-
-struct ion_handle;
-/**
- * enum ion_heap_types - list of all possible types of heaps
- * @ION_HEAP_TYPE_SYSTEM:	 memory allocated via vmalloc
- * @ION_HEAP_TYPE_SYSTEM_CONTIG: memory allocated via kmalloc
- * @ION_HEAP_TYPE_CARVEOUT:	 memory allocated from a prereserved
- * 				 carveout heap, allocations are physically
- * 				 contiguous
- * @ION_HEAP_TYPE_DMA:		 memory allocated via DMA API
- * @ION_NUM_HEAPS:		 helper for iterating over heaps, a bit mask
- * 				 is used to identify the heaps, so only 32
- * 				 total heap types are supported
- */
-enum ion_heap_type {
-	ION_HEAP_TYPE_SYSTEM,
-	ION_HEAP_TYPE_SYSTEM_CONTIG,
-	ION_HEAP_TYPE_CARVEOUT,
-	ION_HEAP_TYPE_CHUNK,
-	ION_HEAP_TYPE_DMA,
-	ION_HEAP_TYPE_CUSTOM, /* must be last so device specific heaps always
-				 are at the end of this enum */
-	ION_NUM_HEAPS = 16,
-};
-
-#define ION_HEAP_SYSTEM_MASK		(1 << ION_HEAP_TYPE_SYSTEM)
-#define ION_HEAP_SYSTEM_CONTIG_MASK	(1 << ION_HEAP_TYPE_SYSTEM_CONTIG)
-#define ION_HEAP_CARVEOUT_MASK		(1 << ION_HEAP_TYPE_CARVEOUT)
-#define ION_HEAP_TYPE_DMA_MASK          (1 << ION_HEAP_TYPE_DMA)
-
-#define ION_NUM_HEAP_IDS		sizeof(unsigned int) * 8
-
-/**
- * allocation flags - the lower 16 bits are used by core ion, the upper 16
- * bits are reserved for use by the heaps themselves.
- */
-#define ION_FLAG_CACHED 1		/* mappings of this buffer should be
-					   cached, ion will do cache
-					   maintenance when the buffer is
-					   mapped for dma */
-#define ION_FLAG_CACHED_NEEDS_SYNC 2	/* mappings of this buffer will created
-					   at mmap time, if this is set
-					   caches must be managed manually */
-
-#ifdef __KERNEL__
-struct ion_device;
-struct ion_heap;
-struct ion_mapper;
-struct ion_client;
-struct ion_buffer;
-
-/* This should be removed some day when phys_addr_t's are fully
-   plumbed in the kernel, and all instances of ion_phys_addr_t should
-   be converted to phys_addr_t.  For the time being many kernel interfaces
-   do not accept phys_addr_t's that would have to */
-#define ion_phys_addr_t unsigned long
-
-/**
- * struct ion_platform_heap - defines a heap in the given platform
- * @type:	type of the heap from ion_heap_type enum
- * @id:		unique identifier for heap.  When allocating higher numbers
- * 		will be allocated from first.  At allocation these are passed
- *		as a bit mask and therefore can not exceed ION_NUM_HEAP_IDS.
- * @name:	used for debug purposes
- * @base:	base address of heap in physical memory if applicable
- * @size:	size of the heap in bytes if applicable
- * @align:	required alignment in physical memory if applicable
- * @priv:	private info passed from the board file
- *
- * Provided by the board file.
- */
-struct ion_platform_heap {
-	enum ion_heap_type type;
-	unsigned int id;
-	const char *name;
-	ion_phys_addr_t base;
-	size_t size;
-	ion_phys_addr_t align;
-	void *priv;
-};
-
-/**
- * struct ion_platform_data - array of platform heaps passed from board file
- * @nr:		number of structures in the array
- * @heaps:	array of platform_heap structions
- *
- * Provided by the board file in the form of platform data to a platform device.
- */
-struct ion_platform_data {
-	int nr;
-	struct ion_platform_heap heaps[];
-};
-
-/**
- * ion_reserve() - reserve memory for ion heaps if applicable
- * @data:	platform data specifying starting physical address and
- *		size
- *
- * Calls memblock reserve to set aside memory for heaps that are
- * located at specific memory addresses or of specfic sizes not
- * managed by the kernel
- */
-void ion_reserve(struct ion_platform_data *data);
-
-/**
- * ion_client_create() -  allocate a client and returns it
- * @dev:		the global ion device
- * @heap_type_mask:	mask of heaps this client can allocate from
- * @name:		used for debugging
- */
-struct ion_client *ion_client_create(struct ion_device *dev,
-				     const char *name);
-
-/**
- * ion_client_destroy() -  free's a client and all it's handles
- * @client:	the client
- *
- * Free the provided client and all it's resources including
- * any handles it is holding.
- */
-void ion_client_destroy(struct ion_client *client);
-
-/**
- * ion_alloc - allocate ion memory
- * @client:		the client
- * @len:		size of the allocation
- * @align:		requested allocation alignment, lots of hardware blocks
- *			have alignment requirements of some kind
- * @heap_id_mask:	mask of heaps to allocate from, if multiple bits are set
- *			heaps will be tried in order from highest to lowest
- *			id
- * @flags:		heap flags, the low 16 bits are consumed by ion, the
- *			high 16 bits are passed on to the respective heap and
- *			can be heap custom
- *
- * Allocate memory in one of the heaps provided in heap mask and return
- * an opaque handle to it.
- */
-struct ion_handle *ion_alloc(struct ion_client *client, size_t len,
-			     size_t align, unsigned int heap_id_mask,
-			     unsigned int flags);
-
-/**
- * ion_free - free a handle
- * @client:	the client
- * @handle:	the handle to free
- *
- * Free the provided handle.
- */
-void ion_free(struct ion_client *client, struct ion_handle *handle);
-
-/**
- * ion_phys - returns the physical address and len of a handle
- * @client:	the client
- * @handle:	the handle
- * @addr:	a pointer to put the address in
- * @len:	a pointer to put the length in
- *
- * This function queries the heap for a particular handle to get the
- * handle's physical address.  It't output is only correct if
- * a heap returns physically contiguous memory -- in other cases
- * this api should not be implemented -- ion_sg_table should be used
- * instead.  Returns -EINVAL if the handle is invalid.  This has
- * no implications on the reference counting of the handle --
- * the returned value may not be valid if the caller is not
- * holding a reference.
- */
-int ion_phys(struct ion_client *client, struct ion_handle *handle,
-	     ion_phys_addr_t *addr, size_t *len);
-
-/**
- * ion_map_dma - return an sg_table describing a handle
- * @client:	the client
- * @handle:	the handle
- *
- * This function returns the sg_table describing
- * a particular ion handle.
- */
-struct sg_table *ion_sg_table(struct ion_client *client,
-			      struct ion_handle *handle);
-
-/**
- * ion_map_kernel - create mapping for the given handle
- * @client:	the client
- * @handle:	handle to map
- *
- * Map the given handle into the kernel and return a kernel address that
- * can be used to access this address.
- */
-void *ion_map_kernel(struct ion_client *client, struct ion_handle *handle);
-
-/**
- * ion_unmap_kernel() - destroy a kernel mapping for a handle
- * @client:	the client
- * @handle:	handle to unmap
- */
-void ion_unmap_kernel(struct ion_client *client, struct ion_handle *handle);
-
-/**
- * ion_share_dma_buf() - share buffer as dma-buf
- * @client:	the client
- * @handle:	the handle
- */
-struct dma_buf *ion_share_dma_buf(struct ion_client *client,
-						struct ion_handle *handle);
-
-/**
- * ion_share_dma_buf_fd() - given an ion client, create a dma-buf fd
- * @client:	the client
- * @handle:	the handle
- */
-int ion_share_dma_buf_fd(struct ion_client *client, struct ion_handle *handle);
-
-/**
- * ion_import_dma_buf() - given an dma-buf fd from the ion exporter get handle
- * @client:	the client
- * @fd:		the dma-buf fd
- *
- * Given an dma-buf fd that was allocated through ion via ion_share_dma_buf,
- * import that fd and return a handle representing it.  If a dma-buf from
- * another exporter is passed in this function will return ERR_PTR(-EINVAL)
- */
-struct ion_handle *ion_import_dma_buf(struct ion_client *client, int fd);
-
-#endif /* __KERNEL__ */
-
-/**
- * DOC: Ion Userspace API
- *
- * create a client by opening /dev/ion
- * most operations handled via following ioctls
- *
- */
-
-/**
- * struct ion_allocation_data - metadata passed from userspace for allocations
- * @len:		size of the allocation
- * @align:		required alignment of the allocation
- * @heap_id_mask:	mask of heap ids to allocate from
- * @flags:		flags passed to heap
- * @handle:		pointer that will be populated with a cookie to use to
- *			refer to this allocation
- *
- * Provided by userspace as an argument to the ioctl
- */
-struct ion_allocation_data {
-	size_t len;
-	size_t align;
-	unsigned int heap_id_mask;
-	unsigned int flags;
-	struct ion_handle *handle;
-};
-
-/**
- * struct ion_fd_data - metadata passed to/from userspace for a handle/fd pair
- * @handle:	a handle
- * @fd:		a file descriptor representing that handle
- *
- * For ION_IOC_SHARE or ION_IOC_MAP userspace populates the handle field with
- * the handle returned from ion alloc, and the kernel returns the file
- * descriptor to share or map in the fd field.  For ION_IOC_IMPORT, userspace
- * provides the file descriptor and the kernel returns the handle.
- */
-struct ion_fd_data {
-	struct ion_handle *handle;
-	int fd;
-};
-
-/**
- * struct ion_handle_data - a handle passed to/from the kernel
- * @handle:	a handle
- */
-struct ion_handle_data {
-	struct ion_handle *handle;
-};
-
-/**
- * struct ion_custom_data - metadata passed to/from userspace for a custom ioctl
- * @cmd:	the custom ioctl function to call
- * @arg:	additional data to pass to the custom ioctl, typically a user
- *		pointer to a predefined structure
- *
- * This works just like the regular cmd and arg fields of an ioctl.
- */
-struct ion_custom_data {
-	unsigned int cmd;
-	unsigned long arg;
-};
-
-#define ION_IOC_MAGIC		'I'
-
-/**
- * DOC: ION_IOC_ALLOC - allocate memory
- *
- * Takes an ion_allocation_data struct and returns it with the handle field
- * populated with the opaque handle for the allocation.
- */
-#define ION_IOC_ALLOC		_IOWR(ION_IOC_MAGIC, 0, \
-				      struct ion_allocation_data)
-
-/**
- * DOC: ION_IOC_FREE - free memory
- *
- * Takes an ion_handle_data struct and frees the handle.
- */
-#define ION_IOC_FREE		_IOWR(ION_IOC_MAGIC, 1, struct ion_handle_data)
-
-/**
- * DOC: ION_IOC_MAP - get a file descriptor to mmap
- *
- * Takes an ion_fd_data struct with the handle field populated with a valid
- * opaque handle.  Returns the struct with the fd field set to a file
- * descriptor open in the current address space.  This file descriptor
- * can then be used as an argument to mmap.
- */
-#define ION_IOC_MAP		_IOWR(ION_IOC_MAGIC, 2, struct ion_fd_data)
-
-/**
- * DOC: ION_IOC_SHARE - creates a file descriptor to use to share an allocation
- *
- * Takes an ion_fd_data struct with the handle field populated with a valid
- * opaque handle.  Returns the struct with the fd field set to a file
- * descriptor open in the current address space.  This file descriptor
- * can then be passed to another process.  The corresponding opaque handle can
- * be retrieved via ION_IOC_IMPORT.
- */
-#define ION_IOC_SHARE		_IOWR(ION_IOC_MAGIC, 4, struct ion_fd_data)
-
-/**
- * DOC: ION_IOC_IMPORT - imports a shared file descriptor
- *
- * Takes an ion_fd_data struct with the fd field populated with a valid file
- * descriptor obtained from ION_IOC_SHARE and returns the struct with the handle
- * filed set to the corresponding opaque handle.
- */
-#define ION_IOC_IMPORT		_IOWR(ION_IOC_MAGIC, 5, struct ion_fd_data)
-
-/**
- * DOC: ION_IOC_SYNC - syncs a shared file descriptors to memory
- *
- * Deprecated in favor of using the dma_buf api's correctly (syncing
- * will happend automatically when the buffer is mapped to a device).
- * If necessary should be used after touching a cached buffer from the cpu,
- * this will make the buffer in memory coherent.
- */
-#define ION_IOC_SYNC		_IOWR(ION_IOC_MAGIC, 7, struct ion_fd_data)
-
-/**
- * DOC: ION_IOC_CUSTOM - call architecture specific ion ioctl
- *
- * Takes the argument of the architecture specific ioctl to call and
- * passes appropriate userdata for that ioctl
- */
-#define ION_IOC_CUSTOM		_IOWR(ION_IOC_MAGIC, 6, struct ion_custom_data)
-
-#endif /* _LINUX_ION_H */
diff --git a/libavcodec/arm/sunxi/ion_sunxi.h b/libavcodec/arm/sunxi/ion_sunxi.h
deleted file mode 100644
index d7468aebcd..0000000000
--- a/libavcodec/arm/sunxi/ion_sunxi.h
+++ /dev/null
@@ -1,108 +0,0 @@
-/*
- * include/linux/ion_sunxi.h
- *
- * Copyright(c) 2013-2015 Allwinnertech Co., Ltd.
- *      http://www.allwinnertech.com
- *
- * Author: liugang <liugang@allwinnertech.com>
- *
- * sunxi ion header file
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- */
-
-#ifndef __ION_SUNXI_H
-#define __ION_SUNXI_H
-
-#define ION_HEAP_TYPE_SUNXI_START (ION_HEAP_TYPE_CUSTOM + 1)
-#define ION_HEAP_TYPE_SECURE	  (ION_HEAP_TYPE_SUNXI_START)
-
-typedef struct {
-	long 	start;
-	long 	end;
-}sunxi_cache_range;
-
-typedef struct {
-	void *handle;
-	unsigned long phys_addr;
-	unsigned long size;
-}sunxi_phys_data;
-
-#define DMA_BUF_MAXCNT 	8
-
-typedef struct {
-	unsigned int src_va;
-	unsigned int src_pa;
-	unsigned int dst_va;
-	unsigned int dst_pa;
-	unsigned int size;
-}dma_buf_item;
-
-typedef struct {
-	int multi_dma;
-	unsigned int cnt;
-	dma_buf_item item[DMA_BUF_MAXCNT];
-}dma_buf_group;
-
-#define ION_IOC_SUNXI_FLUSH_RANGE           5
-#define ION_IOC_SUNXI_FLUSH_ALL             6
-#define ION_IOC_SUNXI_PHYS_ADDR             7
-#define ION_IOC_SUNXI_DMA_COPY              8
-#define ION_IOC_SUNXI_DUMP                  9
-
-#ifdef __KERNEL__
-
-int flush_clean_user_range(long start, long end);
-int flush_user_range(long start, long end);
-void flush_dcache_all(void);
-
-/**
- * sunxi_buf_alloc - alloc phys contigous memory in SUNXI platform.
- * @size: size in bytes to allocate.
- * @paddr: store the start phys address allocated.
- *
- * return the start virtual address, or 0 if failed.
- */
-void *sunxi_buf_alloc(unsigned int size, unsigned int *paddr);
-/**
- * sunxi_buf_free - free buffer allocated by sunxi_buf_alloc.
- * @vaddr: the kernel virt addr of the area.
- * @paddr: the start phys addr of the area.
- * @size: size in bytes of the area.
- */
-void sunxi_buf_free(void *vaddr, unsigned int paddr, unsigned int size);
-/**
- * sunxi_alloc_phys - alloc phys contigous memory in SUNXI platform.
- * @size: size in bytes to allocate.
- *
- * return the start phys addr, or 0 if failed.
- */
-u32 sunxi_alloc_phys(size_t size);
-/**
- * sunxi_free_phys - free phys contigous memory allocted by sunxi_alloc_phys.
- * @paddr: the start phys addr of the area.
- * @size: size in bytes of the area.
- */
-void sunxi_free_phys(u32 paddr, size_t size);
-/**
- * sunxi_map_kernel - map phys contigous memory to kernel virtual space.
- * @paddr: the start phys addr of the area.
- * @size: size in bytes of the area.
- *
- * return the start virt addr which is in vmalloc space, or NULL if failed.
- */
-void *sunxi_map_kernel(unsigned int paddr, unsigned int size);
-/**
- * sunxi_unmap_kernel - unmap phys contigous memory from kernel space.
- * @vaddr: the kernel virt addr of the area.
- * @paddr: the start phys addr of the area.
- * @size: size in bytes of the area.
- */
-void sunxi_unmap_kernel(void *vaddr, unsigned int paddr, unsigned int size);
-
-#endif /* __KERNEL__ */
-
-#endif
diff --git a/libavcodec/arm/sunxi/ve.c b/libavcodec/arm/sunxi/ve.c
index b44b17e83c..533fd759cb 100644
--- a/libavcodec/arm/sunxi/ve.c
+++ b/libavcodec/arm/sunxi/ve.c
@@ -19,7 +19,6 @@
 
 #include <fcntl.h>
 #include <pthread.h>
-#include <stddef.h>
 #include <stdint.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -28,140 +27,101 @@
 #include <sys/mman.h>
 #include <sys/file.h>
 #include "ve.h"
-#include "ion.h"
-#include "ion_sunxi.h"
-#include "cedar_ve.h"
+
+
 
 #define LOCKFILE "/tmp/cedar_dev.lck"
 #define DEVICE "/dev/cedar_dev"
-#define PAGE_OFFSET (0xc0000000) // from kernel
+#define PAGE_OFFSET (0xc0000000) // from kernel 0xC0000000
 #define PAGE_SIZE (4096)
 
-#define typeof __typeof__
-
-#define container_of(ptr, type, member) ({                      \
-	const typeof( ((type *)0)->member ) *__mptr = (ptr);    \
-	(type *)( (char *)__mptr - offsetof(type,member) );})
+enum IOCTL_CMD
+{
+/*
+	IOCTL_UNKOWN = 0x100,
+	IOCTL_GET_ENV_INFO,
+	IOCTL_WAIT_VE,
+	IOCTL_RESET_VE,
+	IOCTL_ENABLE_VE,
+	IOCTL_DISABLE_VE,
+	IOCTL_SET_VE_FREQ,
+*/
+	IOCTL_UNKOWN = 0x100,
+	IOCTL_GET_ENV_INFO,
+	IOCTL_WAIT_VE_DE,
+	IOCTL_WAIT_VE_EN,
+	IOCTL_RESET_VE,
+	IOCTL_ENABLE_VE,
+	IOCTL_DISABLE_VE,
+	IOCTL_SET_VE_FREQ,
+
+	IOCTL_CONFIG_AVS2 = 0x200,
+	IOCTL_GETVALUE_AVS2 ,
+	IOCTL_PAUSE_AVS2 ,
+	IOCTL_START_AVS2 ,
+	IOCTL_RESET_AVS2 ,
+	IOCTL_ADJUST_AVS2,
+	IOCTL_ENGINE_REQ,
+	IOCTL_ENGINE_REL,
+	IOCTL_ENGINE_CHECK_DELAY,
+	IOCTL_GET_IC_VER,
+	IOCTL_ADJUST_AVS2_ABS,
+	IOCTL_FLUSH_CACHE
+};
 
-static int fd = -1, lockfd = -1;	
-//void memlist_add(struct ve_mem *mem);	
-//struct mem_list *memlist_find(struct ve_mem *mem);
-//int memlist_del(struct ve_mem *mem);
-//void memlist_del_all();
+struct ve_info
+{
+	uint32_t reserved_mem;
+	int reserved_mem_size;
+	uint32_t registers;
+};
 
-struct memchunk_t
+struct cedarv_cache_range
 {
-	struct ve_mem mem;
-	struct memchunk_t *next;
+	long start;
+	long end;
 };
 
-struct ion_mem
+struct memchunk_t
 {
-	struct ion_handle *handle;
-	int fd;
-	struct ve_mem mem;
+	uint32_t phys_addr;
+	int size;
+	void *virt_addr;
+	struct memchunk_t *next;
 };
 
 static struct
 {
 	int fd;
-	int ion_fd;
 	void *regs;
 	int version;
 	struct memchunk_t first_memchunk;
 	pthread_rwlock_t memory_lock;
 	pthread_mutex_t device_lock;
-} ve = { .fd = -1, .ion_fd = -1, .memory_lock = PTHREAD_RWLOCK_INITIALIZER, .device_lock = PTHREAD_MUTEX_INITIALIZER };
-
-
-struct mem_list {
-	struct ve_mem *mem;
-	struct mem_list *next;
-} *memlist = NULL;
-
-static void memlist_add(struct ve_mem *mem) {
-	struct mem_list *m, *k;
-	if (memlist == NULL) {
-		memlist = (struct mem_list *)malloc(sizeof (struct mem_list));
-		memlist->mem = mem;
-		memlist->next = NULL;
-		return;
-	}
-	m = k = memlist;
-	while (m) {
-		k = m;
-		m = m->next;
-	}
-	m = (struct mem_list *)malloc(sizeof (struct mem_list));
-	m->mem = mem;
-	m->next = NULL;
-	k->next = m;
-}
-
-static struct mem_list *memlist_find(struct ve_mem *mem) {
-	struct mem_list *m = memlist;
-	
-	while (m) {
-		if (m->mem == mem) return m;
-		m = m->next;
-	}
-	return NULL;
-}
-
-static int memlist_del(struct ve_mem *mem) {
-	struct mem_list *m = memlist;
-	struct mem_list *prev = m;
-	
-	while (m) {
-		if (m->mem == mem) {
-			prev->next = m->next;
-			free(m);
-			return 0;
-		}
-		prev = m;
-		m = m->next;
-	}
-	return -1;
-}
+} ve = { .fd = -1, .memory_lock = PTHREAD_RWLOCK_INITIALIZER, .device_lock = PTHREAD_MUTEX_INITIALIZER };
 
-static void memlist_del_all(void) {
-	struct mem_list *m = memlist;
-	
-	while (m) {
-		struct mem_list *k = m;
-		m = m->next;
-		free(k);
-	}
-	memlist = NULL;
-}
+static int lockfd = -1;	
 
 int ve_open(void)
 {
 	if (ve.fd != -1)
 		return 0;
 
-	struct cedarv_env_infomation info;
+	struct ve_info info;
 
 	ve.fd = open(DEVICE, O_RDWR);
 	if (ve.fd == -1)
 		return 0;
 
 	if (ioctl(ve.fd, IOCTL_GET_ENV_INFO, (void *)(&info)) == -1)
-		goto close;
+		goto err;
 
-	ve.regs = mmap(NULL, 0x800, PROT_READ | PROT_WRITE, MAP_SHARED, ve.fd, info.address_macc);
+	ve.regs = mmap(NULL, 0x800, PROT_READ | PROT_WRITE, MAP_SHARED, ve.fd, info.registers);
 	if (ve.regs == MAP_FAILED)
-		goto close;
+		goto err;
 
-	ve.first_memchunk.mem.phys = info.phymem_start - PAGE_OFFSET;
-	ve.first_memchunk.mem.size = info.phymem_total_size;
-
-	if (ve.first_memchunk.mem.size == 0)
-	{
-		ve.ion_fd = open("/dev/ion", O_RDONLY);
-		if (ve.ion_fd == -1)
-			goto unmap;
-	}
+	ve.first_memchunk.phys_addr = info.reserved_mem - PAGE_OFFSET;
+	ve.first_memchunk.size = info.reserved_mem_size;
 
 	ioctl(ve.fd, IOCTL_ENGINE_REQ, 0);
 	ioctl(ve.fd, IOCTL_ENABLE_VE, 0);
@@ -171,13 +131,13 @@ int ve_open(void)
 	writel(0x00130007, ve.regs + VE_CTRL);
 
 	ve.version = readl(ve.regs + VE_VERSION) >> 16;
-	printf("[VDPAU SUNXI] VE version 0x%04x opened.\n", ve.version);
+	printf("[CedarX SUNXI] VE version 0x%04x opened.\n", ve.version);
+	printf("REGS pa: %08X\n", info.registers);
+	printf("MEMORY pa %08X, page offset %08X size %d\n", info.reserved_mem, ve.first_memchunk.phys_addr, ve.first_memchunk.size);
 
 	return 1;
 
-unmap:
-	munmap(ve.regs, 0x800);
-close:
+err:
 	close(ve.fd);
 	ve.fd = -1;
 	return 0;
@@ -213,9 +173,6 @@ void ve_close(void)
 	munmap(ve.regs, 0x800);
 	ve.regs = NULL;
 
-	if (ve.ion_fd != -1)
-		close(ve.ion_fd);
-
 	close(ve.fd);
 	ve.fd = -1;
 }
@@ -253,99 +210,26 @@ void ve_put(void)
 	pthread_mutex_unlock(&ve.device_lock);
 }
 
-static struct ve_mem *ion_malloc(int size)
-{
-	struct ion_mem *imem = calloc(1, sizeof(struct ion_mem));
-	if (!imem)
-	{
-		perror("calloc ion_buffer failed");
-		return NULL;
-	}
-
-	struct ion_allocation_data alloc = {
-		.len = size,
-		.align = 4096,
-		.heap_id_mask = ION_HEAP_TYPE_DMA,
-		.flags = ION_FLAG_CACHED | ION_FLAG_CACHED_NEEDS_SYNC,
-	};
-
-	if (ioctl(ve.ion_fd, ION_IOC_ALLOC, &alloc))
-	{
-		perror("ION_IOC_ALLOC failed");
-		free(imem);
-		return NULL;
-	}
-
-	imem->handle = alloc.handle;
-	imem->mem.size = size;
-
-	struct ion_fd_data map = {
-		.handle = imem->handle,
-	};
-
-	if (ioctl(ve.ion_fd, ION_IOC_MAP, &map))
-	{
-		perror("ION_IOC_MAP failed");
-		free(imem);
-		return NULL;
-	}
-
-	imem->fd = map.fd;
-
-	imem->mem.virt = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, imem->fd, 0);
-	if (imem->mem.virt == MAP_FAILED)
-	{
-		perror("mmap failed");
-		return NULL;
-	}
-
-	sunxi_phys_data phys = {
-		.handle = imem->handle,
-	};
-
-	struct ion_custom_data custom = {
-		.cmd = ION_IOC_SUNXI_PHYS_ADDR,
-		.arg = (unsigned long)(&phys),
-	};
-
-	if (ioctl(ve.ion_fd, ION_IOC_CUSTOM, &custom))
-	{
-		perror("ION_IOC_CUSTOM(SUNXI_PHYS_ADDR) failed");
-		free(imem);
-		return NULL;
-	}
-
-	imem->mem.phys = phys.phys_addr - 0x40000000;
-
-	memlist_add(&imem->mem);
-	
-	return &imem->mem;
-}
-
-struct ve_mem *ve_malloc(int size)
+void *ve_malloc(int size)
 {
 	if (ve.fd == -1)
 		return NULL;
 
-	if (ve.ion_fd != -1)
-		return ion_malloc(size);
-
 	if (pthread_rwlock_wrlock(&ve.memory_lock))
 		return NULL;
 
 	void *addr = NULL;
-	struct ve_mem *ret = NULL;
 
 	size = (size + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1);
 	struct memchunk_t *c, *best_chunk = NULL;
 	for (c = &ve.first_memchunk; c != NULL; c = c->next)
 	{
-		if(c->mem.virt == NULL && c->mem.size >= size)
+		if(c->virt_addr == NULL && c->size >= size)
 		{
-			if (best_chunk == NULL || c->mem.size < best_chunk->mem.size)
+			if (best_chunk == NULL || c->size < best_chunk->size)
 				best_chunk = c;
 
-			if (c->mem.size == size)
+			if (c->size == size)
 				break;
 		}
 	}
@@ -353,96 +237,63 @@ struct ve_mem *ve_malloc(int size)
 	if (!best_chunk)
 		goto out;
 
-	int left_size = best_chunk->mem.size - size;
+	int left_size = best_chunk->size - size;
 
-	addr = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, ve.fd, best_chunk->mem.phys + PAGE_OFFSET);
+	addr = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, ve.fd, best_chunk->phys_addr + PAGE_OFFSET);
 	if (addr == MAP_FAILED)
 	{
-		ret = NULL;
+		addr = NULL;
 		goto out;
 	}
 
-	best_chunk->mem.virt = addr;
-	best_chunk->mem.size = size;
+	best_chunk->virt_addr = addr;
+	best_chunk->size = size;
 
 	if (left_size > 0)
 	{
 		c = malloc(sizeof(struct memchunk_t));
-		c->mem.phys = best_chunk->mem.phys + size;
-		c->mem.size = left_size;
-		c->mem.virt = NULL;
+		c->phys_addr = best_chunk->phys_addr + size;
+		c->size = left_size;
+		c->virt_addr = NULL;
 		c->next = best_chunk->next;
 		best_chunk->next = c;
 	}
 
-	ret = &best_chunk->mem;
 out:
 	pthread_rwlock_unlock(&ve.memory_lock);
-	return ret;
-}
-
-static void ion_free(struct ve_mem *mem)
-{
-	if (ve.ion_fd == -1 || !mem)
-		return;
-
-	struct ion_mem *imem = container_of(mem, struct ion_mem, mem);
-
-	if (munmap(mem->virt, mem->size))
-	{
-		perror("munmap failed");
-		return;
-	}
-	
-	memlist_del(mem);
-
-	close(imem->fd);
-
-	struct ion_handle_data handle = {
-		.handle = imem->handle,
-	};
-
-	if (ioctl(ve.ion_fd, ION_IOC_FREE, &handle))
-	{
-		perror("ION_IOC_FREE failed");
-		free(imem);
-		return;
-	}
+	return addr;
 }
 
-void ve_free(struct ve_mem *mem)
+void ve_free(void *ptr)
 {
 	if (ve.fd == -1)
 		return;
 
-	if (mem == NULL)
+	if (ptr == NULL)
 		return;
 
-	if (ve.ion_fd != -1)
-		ion_free(mem);
-
 	if (pthread_rwlock_wrlock(&ve.memory_lock))
 		return;
 
 	struct memchunk_t *c;
 	for (c = &ve.first_memchunk; c != NULL; c = c->next)
 	{
-		if (&c->mem == mem)
+		if (c->virt_addr == ptr)
 		{
-			munmap(c->mem.virt, c->mem.size);
-			c->mem.virt = NULL;
+			munmap(ptr, c->size);
+			c->virt_addr = NULL;
 			break;
 		}
 	}
 
 	for (c = &ve.first_memchunk; c != NULL; c = c->next)
 	{
-		if (c->mem.virt == NULL)
+		if (c->virt_addr == NULL)
 		{
-			while (c->next != NULL && c->next->mem.virt == NULL)
+			while (c->next != NULL && c->next->virt_addr == NULL)
 			{
 				struct memchunk_t *n = c->next;
-				c->mem.size += n->mem.size;
+				c->size += n->size;
 				c->next = n->next;
 				free(n);
 			}
@@ -454,99 +305,46 @@ void ve_free(struct ve_mem *mem)
 
 uint32_t ve_virt2phys(void *ptr)
 {
-	uint32_t addr = 0;
-	
 	if (ve.fd == -1)
 		return 0;
-	
-	if (ve.ion_fd != -1) {
-		
-		struct mem_list *m = memlist;
-		
-		while (m) {
-			struct ve_mem *mem = m->mem;
-			if (!mem) {
-				m = m->next;
-				continue;
-			}
-			
-			//printf("c->mem: virt 0x%08X, phys 0x%08X, ptr 0x%08X\n", (unsigned int)mem->virt, mem->phys, (unsigned int)ptr);
-			if (mem->virt == NULL)
-				continue;
 
-			if (mem->virt == ptr)
-			{
-				addr = mem->phys;
-				break;
-			}
-			else if (ptr > mem->virt && ptr < (mem->virt + mem->size))
-			{
-				addr = mem->phys + (ptr - mem->virt);
-				break;
-			}
-			m = m->next;
-		}
-		return addr;
-	}
-	
-
-	//if (pthread_rwlock_rdlock(&ve.memory_lock))
-	//	return 0;
+	if (pthread_rwlock_rdlock(&ve.memory_lock))
+		return 0;
 
-	
+	uint32_t addr = 0;
 
 	struct memchunk_t *c;
 	for (c = &ve.first_memchunk; c != NULL; c = c->next)
 	{
-		printf("c->mem: virt 0x%08X, phys 0x%08X, ptr 0x%08X\n", (unsigned int)c->mem.virt, c->mem.phys, (unsigned int)ptr);
-		if (c->mem.virt == NULL)
+		if (c->virt_addr == NULL)
 			continue;
 
-		if (c->mem.virt == ptr)
+		if (c->virt_addr == ptr)
 		{
-			addr = c->mem.phys;
+			addr = c->phys_addr;
 			break;
 		}
-		else if (ptr > c->mem.virt && ptr < (c->mem.virt + c->mem.size))
+		else if (ptr > c->virt_addr && ptr < (c->virt_addr + c->size))
 		{
-			addr = c->mem.phys + (ptr - c->mem.virt);
+			addr = c->phys_addr + (ptr - c->virt_addr);
 			break;
 		}
 	}
 
-	//pthread_rwlock_unlock(&ve.memory_lock);
+	pthread_rwlock_unlock(&ve.memory_lock);
 	return addr;
 }
 
-
-void ve_flush_cache(struct ve_mem *mem)
+void ve_flush_cache(void *start, int len)
 {
 	if (ve.fd == -1)
 		return;
 
-	if (ve.ion_fd != -1)
+	struct cedarv_cache_range range =
 	{
-		sunxi_cache_range range = {
-			.start = (long)mem->virt,
-			.end = (long)mem->virt + mem->size,
-		};
-
-		struct ion_custom_data cache = {
-			.cmd = ION_IOC_SUNXI_FLUSH_RANGE,
-			.arg = (unsigned long)(&range),
-		};
-
-		if (ioctl(ve.ion_fd, ION_IOC_CUSTOM, &cache))
-			perror("ION_IOC_CUSTOM(SUNXI_FLUSH_RANGE) failed");
-	}
-	else
-	{
-		struct cedarv_cache_range range =
-		{
-			.start = (int)mem->virt,
-			.end = (int)mem->virt + mem->size
-		};
+		.start = (int)start,
+		.end = (int)(start + len)
+	};
 
-		ioctl(ve.fd, IOCTL_FLUSH_CACHE, (void*)(&range));
-	}
+	ioctl(ve.fd, IOCTL_FLUSH_CACHE, (void*)(&range));
 }
diff --git a/libavcodec/arm/sunxi/ve.h b/libavcodec/arm/sunxi/ve.h
index c5dcc7270a..5b4049d44e 100644
--- a/libavcodec/arm/sunxi/ve.h
+++ b/libavcodec/arm/sunxi/ve.h
@@ -31,17 +31,10 @@ int ve_wait(int timeout);
 void *ve_get(int engine, uint32_t flags);
 void ve_put(void);
 
-struct ve_mem
-{
-	void *virt;
-	uint32_t phys;
-	int size;
-};
-
-struct ve_mem *ve_malloc(int size);
-void ve_free(struct ve_mem *mem);
-void ve_flush_cache(struct ve_mem *mem);
+void *ve_malloc(int size);
+void ve_free(void *ptr);
 uint32_t ve_virt2phys(void *ptr);
+void ve_flush_cache(void *start, int len);
 
 static inline void writeb(uint8_t val, void *addr)
 {
@@ -60,11 +53,9 @@ static inline uint32_t readl(void *addr)
 
 #define VE_ENGINE_MPEG			0x0
 #define VE_ENGINE_H264			0x1
-#define VE_ENGINE_HEVC			0x4
 #define VE_ENGINE_AVC			0xb
 
 #define VE_CTRL				0x000
-#define VE_EXTRA_OUT_FMT_OFFSET		0x0e8
 #define VE_VERSION			0x0f0
 
 #define VE_MPEG_PIC_HDR			0x100
@@ -92,10 +83,13 @@ static inline uint32_t readl(void *addr)
 #define VE_MPEG_BACK_CHROMA		0x15c
 #define VE_MPEG_IQ_MIN_INPUT		0x180
 #define VE_MPEG_QP_INPUT		0x184
-
+#define VE_MPEG_JPEG_SIZE		0x1b8
+#define VE_MPEG_JPEG_RES_INT		0x1c0
 #define VE_MPEG_ROT_LUMA		0x1cc
 #define VE_MPEG_ROT_CHROMA		0x1d0
 #define VE_MPEG_SDROT_CTRL		0x1d4
+#define VE_MPEG_RAM_WRITE_PTR		0x1e0
+#define VE_MPEG_RAM_WRITE_DATA		0x1e4
 
 #define VE_H264_FRAME_SIZE		0x200
 #define VE_H264_PIC_HDR			0x204
@@ -112,8 +106,6 @@ static inline uint32_t readl(void *addr)
 #define VE_H264_VLD_LEN			0x238
 #define VE_H264_VLD_END			0x23c
 #define VE_H264_SDROT_CTRL		0x240
-#define VE_H264_SDROT_LUMA		0x244
-#define VE_H264_SDROT_CHROMA		0x248
 #define VE_H264_OUTPUT_FRAME_IDX	0x24c
 #define VE_H264_EXTRA_BUFFER1		0x250
 #define VE_H264_EXTRA_BUFFER2		0x254
@@ -127,41 +119,6 @@ static inline uint32_t readl(void *addr)
 #define VE_SRAM_H264_REF_LIST1		0x664
 #define VE_SRAM_H264_SCALING_LISTS	0x800
 
-#define VE_HEVC_NAL_HDR			0x500
-#define VE_HEVC_SPS			0x504
-#define VE_HEVC_PIC_SIZE		0x508
-#define VE_HEVC_PCM_HDR			0x50c
-#define VE_HEVC_PPS0			0x510
-#define VE_HEVC_PPS1			0x514
-#define VE_HEVC_SLICE_HDR0		0x520
-#define VE_HEVC_SLICE_HDR1		0x524
-#define VE_HEVC_SLICE_HDR2		0x528
-#define VE_HEVC_CTB_ADDR		0x52c
-#define VE_HEVC_CTRL			0x530
-#define VE_HEVC_TRIG			0x534
-#define VE_HEVC_STATUS			0x538
-#define VE_HEVC_CTU_NUM			0x53c
-#define VE_HEVC_BITS_ADDR		0x540
-#define VE_HEVC_BITS_OFFSET		0x544
-#define VE_HEVC_BITS_LEN		0x548
-#define VE_HEVC_BITS_END_ADDR		0x54c
-#define VE_HEVC_REC_BUF_IDX 		0x55c
-#define VE_HEVC_NEIGHBOR_INFO_ADDR	0x560
-#define VE_HEVC_TILE_LIST_ADDR		0x564
-#define VE_HEVC_TILE_START_CTB		0x568
-#define VE_HEVC_TILE_END_CTB		0x56c
-#define VE_HEVC_BITS_DATA		0x5dc
-#define VE_HEVC_SRAM_ADDR		0x5e0
-#define VE_HEVC_SRAM_DATA		0x5e4
-
-#define VE_SRAM_HEVC_PRED_WEIGHT_LUMA_L0	0x000
-#define VE_SRAM_HEVC_PRED_WEIGHT_CHROMA_L0	0x020
-#define VE_SRAM_HEVC_PRED_WEIGHT_LUMA_L1	0x060
-#define VE_SRAM_HEVC_PRED_WEIGHT_CHROMA_L1	0x080
-#define VE_SRAM_HEVG_PIC_LIST			0x400
-#define VE_SRAM_HEVC_REF_PIC_LIST0		0xc00
-#define VE_SRAM_HEVC_REF_PIC_LIST1		0xc10
-
 #define VE_ISP_INPUT_SIZE		0xa00
 #define VE_ISP_INPUT_STRIDE		0xa04
 #define VE_ISP_CTRL			0xa08
@@ -189,5 +146,4 @@ static inline uint32_t readl(void *addr)
 #define VE_AVC_REC_SLUMA		0xbbc
 #define VE_AVC_MB_INFO			0xbc0
 
-
 #endif
diff --git a/libavcodec/cedrus264.c b/libavcodec/cedrus264.c
index 5e62361609..7586da1ce0 100755
--- a/libavcodec/cedrus264.c
+++ b/libavcodec/cedrus264.c
@@ -178,7 +178,7 @@ static void put_aud(void* regs)
 typedef struct cedrus264Context {
 	AVClass *class;
 	uint8_t *ve_regs;
-	struct ve_mem *input_buf, *output_buf, *reconstruct_buf, *small_luma_buf, *mb_info_buf;
+	uint8_t *input_buf, *output_buf, *reconstruct_buf, *small_luma_buf, *mb_info_buf;
 	unsigned int tile_w, tile_w2, tile_h, tile_h2, mb_w, mb_h, plane_size, frame_size;
 	unsigned int frame_num;
 	int qp, vewait;
@@ -248,14 +248,14 @@ static av_cold int cedrus264_encode_init(AVCodecContext *avctx)
 	writel((c4->mb_w << 16) | (c4->mb_h << 0), c4->ve_regs + VE_ISP_INPUT_SIZE);
 
 	/* Input buffer */
-	writel(c4->input_buf->phys, c4->ve_regs + VE_ISP_INPUT_LUMA);
-	writel(c4->input_buf->phys + c4->plane_size, c4->ve_regs + VE_ISP_INPUT_CHROMA);
+	writel(ve_virt2phys(c4->input_buf), c4->ve_regs + VE_ISP_INPUT_LUMA);
+	writel(ve_virt2phys(c4->input_buf) + c4->plane_size, c4->ve_regs + VE_ISP_INPUT_CHROMA);
 	
 	/* Reference output */
-	writel(c4->reconstruct_buf->phys, c4->ve_regs + VE_AVC_REC_LUMA);
-	writel(c4->reconstruct_buf->phys + c4->tile_w * c4->tile_h, c4->ve_regs + VE_AVC_REC_CHROMA);
-	writel(c4->small_luma_buf->phys, c4->ve_regs + VE_AVC_REC_SLUMA);
-	writel(c4->mb_info_buf->phys, c4->ve_regs + VE_AVC_MB_INFO);
+	writel(ve_virt2phys(c4->reconstruct_buf), c4->ve_regs + VE_AVC_REC_LUMA);
+	writel(ve_virt2phys(c4->reconstruct_buf) + c4->tile_w * c4->tile_h, c4->ve_regs + VE_AVC_REC_CHROMA);
+	writel(ve_virt2phys(c4->small_luma_buf), c4->ve_regs + VE_AVC_REC_SLUMA);
+	writel(ve_virt2phys(c4->mb_info_buf), c4->ve_regs + VE_AVC_MB_INFO);
 
 	/* Encoding parameters */
 	writel(0x00000100, c4->ve_regs + VE_AVC_PARAM);
@@ -288,20 +288,20 @@ static int cedrus264_encode(AVCodecContext *avctx, AVPacket *pkt,
 
 	/* Copy data */
 	result = avpicture_layout((const AVPicture *)frame, AV_PIX_FMT_NV12,
-		avctx->width, avctx->height, c4->input_buf->virt, c4->frame_size);
+		avctx->width, avctx->height, c4->input_buf, c4->frame_size);
  	if(result < 0){
 		av_log(avctx, AV_LOG_ERROR, "Input buffer too small.\n");
 		return AVERROR(ENOMEM);
 	}
-	ve_flush_cache(c4->input_buf);
+	ve_flush_cache(c4->input_buf, c4->frame_size);
 
 	/* flush output buffer, otherwise we might read old cached data */
-	ve_flush_cache(c4->output_buf);
-	
+	ve_flush_cache(c4->output_buf, CEDAR_OUTPUT_BUF_SIZE);
+
 	/* Set output buffer */
 	writel(0x0, c4->ve_regs + VE_AVC_VLE_OFFSET);
-	writel(c4->output_buf->phys, c4->ve_regs + VE_AVC_VLE_ADDR);
-	writel(c4->output_buf->phys + CEDAR_OUTPUT_BUF_SIZE - 1, c4->ve_regs + VE_AVC_VLE_END);
+	writel(ve_virt2phys(c4->output_buf), c4->ve_regs + VE_AVC_VLE_ADDR);
+	writel(ve_virt2phys(c4->output_buf) + CEDAR_OUTPUT_BUF_SIZE - 1, c4->ve_regs + VE_AVC_VLE_END);
 
 	writel(0x04000000, c4->ve_regs + 0xb8c); // ???
 	
@@ -333,11 +333,12 @@ static int cedrus264_encode(AVCodecContext *avctx, AVPacket *pkt,
 
 	size = readl(c4->ve_regs + VE_AVC_VLE_LENGTH) / 8;
 	if(size > 0){
-		if ((result = ff_alloc_packet(pkt, size)) < 0){
+		if ((result = ff_alloc_packet2(avctx, pkt, size, 0)) < 0){
 			av_log(avctx, AV_LOG_ERROR, "Packet allocation error.\n");
 			return result;
 		}
-		memcpy(pkt->data, c4->output_buf->virt, size);
+		memcpy(pkt->data, c4->output_buf, size);
+
 
 		pkt->pts = pkt->dts = frame->pts - ff_samples_to_time_base(avctx, avctx->delay);
 		pkt->flags |= AV_PKT_FLAG_KEY;
-- 
2.30.2

